/******************************************************************************
 * Copyright (c) 2012 Aitor Aldoma
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 ******************************************************************************/

#ifndef FAAT_PCL_PARTIAL_PCD_SOURCE_H_
#define FAAT_PCL_PARTIAL_PCD_SOURCE_H_

#include "source.h"
#include <pcl/visualization/pcl_visualizer.h>
#include <vtkPlatonicSolidSource.h>
#include <vtkLoopSubdivisionFilter.h>
#include <vtkTriangle.h>
#include <vtkTransform.h>
#if VTK_MAJOR_VERSION == 6 
#include <vtkHardwareSelector.h>
#else 
#include <vtkVisibleCellSelector.h>
#endif
#include <vtkSelection.h>
#include <vtkCellArray.h>
#include <vtkTransformFilter.h>
//#include "pcl/recognition/hv/occlusion_reasoning.h"
#include <v4r/io/filesystem.h>
#include "v4r/common/faat_3d_rec_framework_defines.h"

namespace v4r
{
    /**
     * \brief Data source class to generate partial views from a "full" 3D model obtained
     * by fusing different views of the sensor. The partial views are generated by placing
     * the camera around the object (camera positions can be constrained) to avoid using viewpoints
     * where the model has not been trained.
     * \author Aitor Aldoma
     */

    template<typename Full3DPointT = pcl::PointXYZRGBNormal, typename PointInT = pcl::PointXYZRGB, typename OutModelPointT = pcl::PointXYZRGB>
      class PartialPCDSource : public Source<PointInT>
      {

        typedef Source<PointInT> SourceT;
        typedef Model<OutModelPointT> ModelT;
        typedef boost::shared_ptr<ModelT> ModelTPtr;

        using SourceT::path_;
        using SourceT::models_;
        using SourceT::load_views_;
        using SourceT::load_into_memory_;
        using SourceT::view_prefix_;
        using SourceT::pose_prefix_;

        bool use_vertices_;
        int tes_level_;
        int resolution_;
        float radius_sphere_;
        float dot_normal_;
        bool gen_organized_;
        int cx_size, cy_size;
        float f_;
        bool gen_inplane_rotations_;
        float angle_incr_inplane_;

        //std::function<bool (const Eigen::Vector3f &)> campos_constraints_func_;
        boost::function<bool
        (const Eigen::Vector3f &)> campos_constraints_func_;

        void
        loadInMemorySpecificModel(ModelT & model);

        void
        loadOrGenerate (const std::string &model_path, ModelT & model);

        void assembleModelFromViewsAndPoses(ModelT & model,
                                       std::vector<Eigen::Matrix4f, Eigen::aligned_allocator<Eigen::Matrix4f> > & poses,
                                       std::vector<pcl::PointIndices> & indices,
                                       typename pcl::PointCloud<PointInT>::Ptr &model_cloud);
      public:

        PartialPCDSource ()
        {
          use_vertices_ = false;
          tes_level_ = 1;
          dot_normal_ = 0.1;
          load_into_memory_ = true;
          gen_organized_ = false;
          cx_size = cy_size = 150.f;
          gen_inplane_rotations_ = false;
          f_ = 525.f;
        }

        void genInPlaneRotations(bool b, float angle = 0.f)
        {
          gen_inplane_rotations_ = b;
          angle_incr_inplane_ = angle;
        }

        void
        loadInMemorySpecificModelAndView(const std::string & dir, ModelT & model, int view_id);

        void
        setDotNormal (float f)
        {
          dot_normal_ = f;
        }

        void
        setCamPosConstraints (boost::function<bool
        (const Eigen::Vector3f &)> & bb)
        {
          campos_constraints_func_ = bb;
        }

        void
        setTesselationLevel (int lev)
        {
          tes_level_ = lev;
        }

        void
        setRadiusSphere (float r)
        {
          radius_sphere_ = r;
        }

        void
        setUseVertices (bool b)
        {
          use_vertices_ = b;
        }

        void
        setGenOrganized(bool b)
        {
          gen_organized_ = b;
        }

        void setWindowSizeAndFocalLength(int cx, int cy, float f)
        {
          cx_size = cx;
          cy_size = cy;
          f_ = f;
        }

        /**
         * \brief Creates the model representation of the training set, generating views if needed
         */
        void
        generate ()
        {
          models_.clear();
          std::vector < std::string > model_files = v4r::io::getFilesInDirectory(path_, ".3D_model.pcd", true );
          std::cout << "There are " << model_files.size() << " models." << std::endl;

          for (const std::string &model_file : model_files)
          {
              ModelTPtr m(new ModelT);

              std::vector < std::string > strs;
              boost::split (strs, model_file, boost::is_any_of ("/\\"));
              //            std::string name = strs[strs.size () - 1];

              if (strs.size () == 2)  // class_name/id_name/3D_model.pcd
              {
                  m->id_ = strs[0];
              }
              else if (strs.size()==3)
              {
                  m->class_ = strs[0];
                  m->id_ = strs[1];
              }
              else
              {
                  std::cerr << "Given path " << path_ << " does not have required file structure: (optional: object_class_name)/object_id_name/3D_model.pcd !" << std::endl;
                  m->id_ = strs[0];
              }

              //check if the model has to be loaded according to the list
              if(!this->isModelIdInList(m->id_))
                  continue;

              //check which of them have been trained using training_dir and the model_id_
              //load views, poses and self-occlusions for those that exist
              //generate otherwise
              loadOrGenerate (path_ + "/" + model_file, *m);
              models_.push_back (m);
          }
        }

      };
}

#endif /* PARTIAL_PCD_SOURCE_H_ */
